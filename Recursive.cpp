/*
Recursive Function(재귀)
- 자신을 정의하거나 호출하는 함수
- 프로그램에서의 재귀는 복잡한 문제를 더 단순한 하위 문제로 나누어 해결하는 데 사용

기본구조
1. 기저조건(종료조건) : 이 조건이 충족되면 함수는 더이상 자기 자신을 호출하지 않고 종료. 모든 재귀함수는 적어도 하나의 종료조건을 가져야 한다. 안그러면 무한으로 돈다..
2. 재귀단계 : 함수가 자기 자신을 호출하는 단계. 이 단계에서 더 작읜 하위 문제로 분해

장점
1. 복잡한 문제를 더 작은 문제로 분할하여 간결하게 해결할 수 있다.
2. 반복문을 쓰지 않고 재귀적 호출을 통해 해결할 수 있다.
3. Tree나 Graph와 같은 구조를 처리할 때 재귀는 직관적인 방법 제공

단점
1. 성능문제 : 재귀호출마다 함수 호출스택에 기록되므로 메모리 사용량이 증가할 수 있다
2. 이해하기 어려움 : 복잡한 재귀는 디버깅이 어려울 수 있다.
*/
#include<iostream>
using namespace std;

// 팩토리얼 : n부터 1까지의 모든 정수의 곱
int factorial(int n) {
	// 조건
	if (n <= 1)return 1;


	// 재귀 단계
	return n * factorial(n - 1);
}
/*
위 함수의 호출단계
1. 첫번째 호출 : 함수는 factorial(3)에서 종료조건을 확인 후
// n이 1보다 크므로 factorial(2)를 리턴하려고 함
2. 두번째 호출 : factorial(2) 호출
// 마찬가지로 n이 1보다 크기 때문에 factorial(1)을 리턴하려고함
3. 세번째 호출 : factorial(1) 호출. 이번에는 종료 조건을 만족하므로 1을 리턴
4. factorial(1) 1을 반환 factorial(2)는 2*1 반환. factorial(3)은 3*2를 반환
*/

void Print() {
	Print();
}

int main() {
	// Print();
	
	int res = factorial(3);

	cout << res << "\n";
}

/*
과제1 . 피보나치수열 (첫번째, 두번째 항이 1이고 그다음 항부터는 앞 두항의 합)
31,1,2,3,5,8,13,,,

2. 하노이탑

3. singlelinkedList delete 어쩌구 채우는거
*/